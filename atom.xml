<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jianguoli&#39;s</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jianguoli.com/"/>
  <updated>2018-07-22T13:14:42.000Z</updated>
  <id>http://jianguoli.com/</id>
  
  <author>
    <name>jianguoli</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EffectiveJava读书笔记之创建和销毁对象</title>
    <link href="http://jianguoli.com/2018/07/22/EffectiveJava%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%88%9B%E5%BB%BA%E5%92%8C%E9%94%80%E6%AF%81%E5%AF%B9%E8%B1%A1/"/>
    <id>http://jianguoli.com/2018/07/22/EffectiveJava读书笔记之创建和销毁对象/</id>
    <published>2018-07-22T11:03:26.000Z</published>
    <updated>2018-07-22T13:14:42.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Creating and Destroying Objects</p></blockquote><p>读书笔记，主要内容来自《Effective Java中文版 第2版》，辅以《Effective Java 3rd》</p><p>本文的主题是创建和销毁对象：何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时地销毁，以及如何管理对象销毁之前必须进行的各种清理动作。</p><a id="more"></a><h3 id="考虑用静态工厂方法代替构造器"><a href="#考虑用静态工厂方法代替构造器" class="headerlink" title="考虑用静态工厂方法代替构造器"></a>考虑用静态工厂方法代替构造器</h3><blockquote><p>Consider static factory methods instead of constructors</p></blockquote><p>例子：</p><ul><li><code>Boolean.valueOf(boolean)</code></li></ul><p>优势：</p><ul><li>静态工厂方法有名字，更直观，可读性高</li><li>不会每次被调用的时候都创造新对象</li><li>可以返回其返回类型的任意子类型（基于接口的框架<em>interface-based frameworks</em>，<code>java.util.Collections</code>）</li><li>可以根据入参的不同得到不同的对象（<code>java.util.EnumSet</code>），内在实现对使用者隐藏</li><li>静态工厂方法返回的对象所属的类可以在编写该方法时不存在（服务提供者框架<em>service provider frameworks</em>，JDBC，<code>java.util.ServiceLoader</code>(spi)）</li></ul><p>缺点：</p><ul><li>只提供静态工厂方法的类不能有子类，不过却可以使编程者不得不用组合(composition)代替继承</li><li>静态工厂方法不容易让该类的使用者发现，不过可以起方法名时用一些惯用的名称</li></ul><table><thead><tr><th>方法名</th><th>惯用法</th><th>例子</th></tr></thead><tbody><tr><td><strong>from</strong></td><td>返回的实例和它的参数具有相同的值</td><td><code>Date d = Date.from(instant);</code></td></tr><tr><td><strong>of</strong></td><td>返回的实例包含传入的的多个参数</td><td><code>Set&lt;Rank&gt; faceCards = EnumSet.of(JACK, QUEEN, KING);</code></td></tr><tr><td><strong>valueOf</strong></td><td>啰嗦版(verbose)</td><td><code>BigInteger prime  =BigInteger.valueOf(Integer.MAX_VALUE);</code></td></tr><tr><td><strong>instance</strong> or <strong>getInstance</strong></td><td>返回的实例通过方法的参数来描述，但不能说拥有相同的值</td><td><code>StackWalker luke = StackWalker.getInstance(options);</code></td></tr><tr><td><strong>create</strong> or <strong>newInstance</strong></td><td>同上，但是确保返回的是新实例</td><td><code>Object newArray = Array.newInstance(classObject, arrayLen);</code></td></tr><tr><td><strong>get<em>Type</em></strong></td><td>像<strong>getInstance</strong>，但是用于不同的类，<em>Type</em>指返回的对象的类型</td><td><code>FileStore fs = Files.getFileStore(path);</code></td></tr><tr><td><strong>new<em>Type</em></strong></td><td>同上</td><td><code>BufferedReader br = Files.newBufferedReader(path);</code></td></tr><tr><td><strong><em>type</em></strong></td><td>同上，精简版</td><td><code>List&lt;Complaint&gt; litany = Collections.list(legacyLitany);</code></td></tr></tbody></table><h3 id="遇到多个构造器参数时要考虑用构造器"><a href="#遇到多个构造器参数时要考虑用构造器" class="headerlink" title="遇到多个构造器参数时要考虑用构造器"></a>遇到多个构造器参数时要考虑用构造器</h3><blockquote><p>Consider a builder when faced with many constructor parameters</p></blockquote><p>缘由：</p><ul><li>重叠构造器模式(telescoping constructor pattern)可行，但是当有许多参数的时候，客户端代码会很难编写，并且仍然较难以阅读</li><li>JavaBean模式将构造过程分到多个调用中，使得在构造过程中JavaBean可能处于不一致的状态，可能会不安全；也无法使得得到的对象是不可变的</li></ul><p>使用构造器，更灵活，一行调用：</p><p><code>People p = new People.Builder().age(18).name(&quot;Jack&quot;).address(&quot;somewhere&quot;).build();</code></p><p>相比传统的抽象工厂实现（通过<code>Class.newInstance</code>，必须要有可访问的无参构造器），弥补了不足。</p><p>缺点：</p><ul><li>必须先创建它的构建器，在十分注重性能的情况下，可能会是种开销</li><li>比重叠构造器模式更加冗长</li></ul><h3 id="通过私有构造器或者枚举类型强化Singleton属性"><a href="#通过私有构造器或者枚举类型强化Singleton属性" class="headerlink" title="通过私有构造器或者枚举类型强化Singleton属性"></a>通过私有构造器或者枚举类型强化Singleton属性</h3><blockquote><p>Enforce the singleton property with a private constructor or an enum type</p></blockquote><p>之前的Singleton实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Singleton with public final field</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Singleton with static factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（强行找）缺点：</p><ul><li>可以借助<code>AccessibleObject.setAccessible</code>方法，通过反射机制调用私有构造器；如果需要抵御这种攻击，可以修改构造器，让它在被要求创建第二个实例的时候抛出异常。</li></ul><p>静态工厂方法的优点：</p><ul><li>API很清楚表明这是个singleton</li><li>更便于修改，而不去动API</li><li>can write a <em>generic singleton factory</em>???</li><li>能以方法引用（<em>method reference</em>）的形式当作supplier来用，比如<code>Elvis::instance</code>是<code>Supplier&lt;Elvis&gt;</code></li></ul><p>需要序列化时的增强，如下避免反序列化时得到不唯一对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把readResolve方法加到Singleton类中，用transient修饰实例成员变量(防止攻击reflection attack)，</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举来实现Singleton：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Elvis &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优势：</p><ul><li>更加简洁，无偿提供序列化机制，绝对防止多次实例化</li></ul><p>劣势：</p><ul><li>无法继承别的类（枚举已经extends Enum了），但可以实现接口</li></ul><h3 id="通过私有构造器强化不可实例化的能力"><a href="#通过私有构造器强化不可实例化的能力" class="headerlink" title="通过私有构造器强化不可实例化的能力"></a>通过私有构造器强化不可实例化的能力</h3><blockquote><p>Enforce noninstantiability with a private constructor</p></blockquote><p>像<code>java.lang.Math</code>或者<code>java.util.Arrays</code>这样的工具类<code>utility class</code>不希望被实例化，实例对它没有任何意义。为了强制该类不可被实例化，将默认无参构造函数私有化即可。副作用：使得这个类不能被子类化。不建议将该类做成抽象类来避免实例化的原因：误导用户以为这种类是专门为了继承而设计的。</p><h3 id="使用依赖注入而不是硬绑定（写死）资源对象"><a href="#使用依赖注入而不是硬绑定（写死）资源对象" class="headerlink" title="使用依赖注入而不是硬绑定（写死）资源对象"></a>使用依赖注入而不是硬绑定（写死）资源对象</h3><blockquote><p>Prefer dependency injection to hardwiring resources</p></blockquote><p>依赖基础资源(underlying resources)的类，不适宜被写做静态工具类或是单例，因为资源不是固定的。为此添加修改依赖的资源对象的方法也是不合适的，这样在并发环境就容易出错不可用了。可以使用依赖注入模式解决动态注入资源对象的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖注入提供灵活性和可测性</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lexicon dictionary;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpecllChecker</span><span class="params">(Lexicon dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dictionary = Objects.requireNonNull(dictionary);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">suggestions</span><span class="params">(String typo)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>通过构造器传入资源对象</li><li>传入资源工厂对象（工厂方法模式）</li><li>使用Java 8提供的<code>Supplier&lt;T&gt;</code></li><li>使用依赖注入框架，如<a href="https://github.com/square/dagger" target="_blank" rel="noopener">Dagger</a>，<a href="https://github.com/google/guice" target="_blank" rel="noopener">Guice</a>，<a href="https://spring.io/projects/spring-framework" target="_blank" rel="noopener">Spring</a></li></ol><h3 id="避免创建不必要的对象"><a href="#避免创建不必要的对象" class="headerlink" title="避免创建不必要的对象"></a>避免创建不必要的对象</h3><blockquote><p>Avoid creating unnecessary objects</p></blockquote><p>一般来说，最好能重用对象而不是在每次需要的时候都创建一个相同功能的新对象。</p><ul><li>如果对象是不可变的（immutable），它就始终可以被重用。</li><li>避免<code>String s = new String(&quot;stringette&quot;);</code>，使用<code>String s = &quot;stringette&quot;</code>。<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5" target="_blank" rel="noopener">JVM保证</a>只要字符串对象包含相同的字符串字面常量，该对象就会被重用。</li><li>创建一次<code>Pattern.compile(RegEx)</code>后再<code>.matcher(String).matches()</code>优于频繁直接通过<code>String.matches(RegEx)</code>，因为后者会内部会创建一个Pattern实例。</li><li>对于同时提供了静态工厂方法和构造器的不可变类，通常可以使用静态工厂方法而不是构造器，以避免创建不必要的对象。</li><li>使用静态代码块之类的方式初始化且只初始化一次那些已经不会被修改的可变对象。比如<code>private static final Logger logger = LoggerFactory.getLogger(Xxx.class);</code>。</li><li>要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱。</li></ul><p>误区：</p><ul><li>错误认为：创建对象的代价非常昂贵，我们应该要尽可能地避免创建对象。小对象的创建和回收动作是非常廉价的，特别是在现代的JVM实现上。通过创建附加的对象，提升程序的清晰性、简洁性和功能性，这通常是件好事。</li><li>错误做法：通过维护自己的对象池（object pool）来避免创建对象。除非池中的对象是非常重量级的，比如数据库连接。一般而言，维护自己的对象池必定会把代码弄得很乱，同时增加内存占用，并且还会损害性能。现在JVM实现具有高度优化的垃圾回收器，其性能很容易就会超过轻量级对象池的性能。</li></ul><div class="note default"><p>这点让我想到一个说法：不要自以为是的去优化，JVM比你更懂怎么优化代码</p></div><h3 id="消除过期的对象引用"><a href="#消除过期的对象引用" class="headerlink" title="消除过期的对象引用"></a>消除过期的对象引用</h3><blockquote><p>Eliminate obsolete object references</p></blockquote><p>Java虽然有垃圾回收功能（GC），不代表程序员自己就不再需要考虑内存管理的事情了。</p><ul><li>内存泄露的一个常见来源是自己管理内存的类</li></ul><p>比如Stack类，自己管理内存。存储池包含了elements数组的元素。数组活动区域中的元素是已分配的(allocated)，而数组其余部分的元素则是自由的(free)。但是垃圾回收器并不知道这一点，对于GC而言，elements数组中的所有对象引用都同等有效。</p><p><img src="https://jianguoli-blog-img.oss-cn-hangzhou.aliyuncs.com/201807/Stack_ElementData.png" alt="Stack类自己管理内存"></p><p>对于这类易发生内存泄漏的，一旦元素被释放掉，则该元素中包含的任何对象引用都应该被清空（置为null）。</p><ul><li>另一个常见来源是缓存</li></ul><p>一旦你把对象引用放到缓存中，它就很容易被遗忘，从而使得它不再有用之后很长一段时间内任然留在缓存中。如果缓存项的生命周期是由该键的外部引用而不是由值决定时，那么可以用<code>WeakHashMap</code>。当缓存项的生命周期不容易确定时，可以由一个后台线程（比如<code>Timer</code>或<code>ScheduledThreadPoolExecutor</code>）来做清楚工作，或是再给缓存添加新条目的时候顺便进行清理（比如<code>LinkedHashMap.removeEldestEntry</code>）。对于更加复杂的缓存，必须直接使用<code>java.lang.ref</code>，参考 <a href="https://www.ibm.com/developerworks/cn/java/j-lo-langref/index.html" target="_blank" rel="noopener">深入探讨 java.lang.ref包</a>。</p><h3 id="避免使用终结方法"><a href="#避免使用终结方法" class="headerlink" title="避免使用终结方法"></a>避免使用终结方法</h3><blockquote><p>Avoid finalizers and cleaners</p></blockquote><p>终结方法的缺点在于不能保证被及时地执行。Java语言规范不仅不保证终结方法会被及时执行，而且根本就不保证它们会被执行。<code>System.gc</code>和<code>System.runFinalization</code>这两个方法虽然确实增加了终结方法被执行的机会，但是并不保证终结方法一定会被执行，除了<code>System.runFinalizersOnExit</code>。</p><p>缺点之二：如果未被捕获的异常在终结过程中被跑出来，会被忽略，而且该对象的终结过程也会终止。</p><p>缺点之三：使用终结方法有非常严重的性能损失。？？？</p><blockquote><p><em>Effective Java 3rd</em>解释：This is primarily because finalizers inhibit efficient garbage collection. Cleaners are comparable in speed to finalizers if you use them to clean all instances of the class (about 500 ns per instance on my machine), but cleaners are much faster if you use them only as a safety net, as discussed below. Under these circumstances, creating, cleaning, and destroying an object takes about 66 ns on my machine, which means you pay a factor of five (not fifty) for the insurance of a safety net if you don’t use it.</p></blockquote><p>解决方案：提供一个显示的终止方法（比如实现AutoCloseable接口，再配合try-with-resources）。同时该实例必须记录下自己是否已经被终止了。</p><p><em>Effective Java 3rd</em>的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// An autocloseable class using a cleaner as a safety net</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Room</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Cleaner cleaner = Cleaner.create();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Resource that requires cleaning</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numJunkPiles; <span class="comment">// Number of junk piles in this room</span></span><br><span class="line">        </span><br><span class="line">        State(<span class="keyword">int</span> numJunkPiles) &#123;</span><br><span class="line">            <span class="keyword">this</span>.numJunkPiles = numJunkPiles;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Invoked by close method or cleaner</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Cleaning room"</span>);</span><br><span class="line">            numJunkPiles = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The state of this room, shared with our cleanable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> State state;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Our cleanable. Cleans the room when it's eligible for gc</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Cleaner.Cleanable cleanable;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Room</span><span class="params">(<span class="keyword">int</span> numJunkPiles)</span> </span>&#123;</span><br><span class="line">        state = <span class="keyword">new</span> State(numJunkPiles);</span><br><span class="line">        cleanable = cleaner.register(<span class="keyword">this</span>, state);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cleanable.clean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adult</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(Room myRoom = <span class="keyword">new</span> Room(<span class="number">7</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Goodbye"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adult</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Room(<span class="number">99</span>);</span><br><span class="line">        System.out.println(<span class="string">"Peace out"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用try-with-resources替代try-finally"><a href="#用try-with-resources替代try-finally" class="headerlink" title="用try-with-resources替代try-finally"></a>用try-with-resources替代try-finally</h3><blockquote><p>Prefer try-with-resources to try-finally</p></blockquote><p>Java 7推出的try-with-resources比传统的try-finally代码更短、可读性更高。而且这一机制会阻止(suppress)关闭资源时发生的异常，使得我们能更直接看到业务代码里抛出的我们更关心的异常。要获得被suppressed的异常信息可通过<code>Throwable.getSuppressed</code>方法得到。</p><p>两个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-with-resources - the the best way to close resources!</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// try-with-resources on multiple resources - short and sweet</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">    OutputStream out = <span class="keyword">new</span> FileOutputStream(dst)) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>)</span><br><span class="line">        out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Creating and Destroying Objects&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;读书笔记，主要内容来自《Effective Java中文版 第2版》，辅以《Effective Java 3rd》&lt;/p&gt;
&lt;p&gt;本文的主题是创建和销毁对象：何时以及如何创建对象，何时以及如何避免创建对象，如何确保它们能够适时地销毁，以及如何管理对象销毁之前必须进行的各种清理动作。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>整理下收集的各类Java资源网址（07/16更新）</title>
    <link href="http://jianguoli.com/2018/07/15/%E6%95%B4%E7%90%86%E4%B8%8B%E6%94%B6%E9%9B%86%E7%9A%84%E5%90%84%E7%B1%BBJava%E8%B5%84%E6%BA%90%E7%BD%91%E5%9D%80%EF%BC%88%E9%9A%8F%E7%BC%98%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>http://jianguoli.com/2018/07/15/整理下收集的各类Java资源网址（随缘更新）/</id>
    <published>2018-07-15T08:44:20.000Z</published>
    <updated>2018-07-17T07:26:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>这下疲了乏了，就多了个选择了……更新这篇O(∩_∩)O<br>不过收藏再多，不去看，那就毫无意义了<br><del>倒是能满足不知道从何而来的收集癖</del></p><a id="more"></a><h3 id="就业指导与知识技能一箩筐"><a href="#就业指导与知识技能一箩筐" class="headerlink" title="就业指导与知识技能一箩筐"></a>就业指导与知识技能一箩筐</h3><p><a href="https://blog.csdn.net/jackfrued/article/details/45035097" target="_blank" rel="noopener">Java就业指导</a><br><a href="http://www.hollischuang.com/archives/489" target="_blank" rel="noopener">Java工程师成神之路</a><br><a href="http://www.cnblogs.com/zuoxiaolong/p/life41.html" target="_blank" rel="noopener">记录2015年年初跳槽的经历！</a><br><a href="https://zhuanlan.zhihu.com/p/28615617" target="_blank" rel="noopener">什么才是java的基础知识？</a></p><h3 id="IT、Java社区-技术网站"><a href="#IT、Java社区-技术网站" class="headerlink" title="IT、Java社区/技术网站"></a>IT、Java社区/技术网站</h3><p><a href="https://www.oschina.net/" target="_blank" rel="noopener">开源中国</a>（每天上去看下<strong>综合资讯</strong>和<strong>软件更新资讯</strong>）<br><a href="https://www.v2ex.com/" target="_blank" rel="noopener">V2EX</a>（程序员论坛）<br><a href="https://coolshell.cn/" target="_blank" rel="noopener">酷壳COOLSHELL</a>（已经不更新了）<br><a href="https://www.ibm.com/developerworks/cn/" target="_blank" rel="noopener">IBM developerWorks CN</a><br><a href="http://www.iteye.com/" target="_blank" rel="noopener">ITEye</a>（虽然好久没更新了）<br><a href="http://www.open-open.com/" target="_blank" rel="noopener">深度开源</a><br><a href="http://www.infoq.com/cn/" target="_blank" rel="noopener">InfoQ中文站</a><br><a href="http://www.importnew.com/" target="_blank" rel="noopener">ImportNew</a><br><a href="http://blog.jobbole.com/" target="_blank" rel="noopener">伯乐在线</a><br><a href="https://juejin.im/" target="_blank" rel="noopener">掘金</a><br><a href="https://toutiao.io/" target="_blank" rel="noopener">开发者头条</a><br><a href="https://www.w3cschool.cn/architectroad/" target="_blank" rel="noopener">W3Cschool的架构师之路</a>（一直以为W3Cschool只有前端的……）</p><h3 id="zookeeper"><a href="#zookeeper" class="headerlink" title="zookeeper"></a>zookeeper</h3><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/index.html" target="_blank" rel="noopener">分布式服务框架 Zookeeper – 管理分布式环境中的数据</a></p><h3 id="rpc"><a href="#rpc" class="headerlink" title="rpc"></a>rpc</h3><p><a href="https://www.zhihu.com/question/25536695" target="_blank" rel="noopener">谁能用通俗的语言解释一下什么是 RPC 框架？</a><br><a href="http://www.cnblogs.com/intsmaze/p/6058765.html" target="_blank" rel="noopener">RPC原来就是Socket——RPC框架到dubbo的服务动态注册，服务路由，负载均衡演化</a><br><a href="http://javatar.iteye.com/blog/1123915" target="_blank" rel="noopener">RPC框架几行代码就够了</a>（作者是dubbo的作者之一）<br><a href="https://my.oschina.net/huangyong/blog/361751" target="_blank" rel="noopener">轻量级分布式 RPC 框架</a><br><a href="https://blog.csdn.net/wuhenzhangxing/article/details/53007203" target="_blank" rel="noopener">dubbo中的多播multicast://224.5.6.7:1234</a></p><h3 id="gradle"><a href="#gradle" class="headerlink" title="gradle"></a>gradle</h3><p><a href="http://blog.jobbole.com/71999/" target="_blank" rel="noopener">Gradle入门系列（1）：简介</a><br><a href="http://www.cnblogs.com/davenkin/p/gradle-learning-1.html" target="_blank" rel="noopener">Gradle学习系列之一——Gradle快速入门</a><br><a href="https://gradle.org/guides/" target="_blank" rel="noopener">Gradle官方guides</a><br><a href="https://spring.io/guides/gs/gradle/" target="_blank" rel="noopener">Spring的Gradle guides</a></p><h3 id="solr"><a href="#solr" class="headerlink" title="solr"></a>solr</h3><p><a href="https://blog.csdn.net/sqh201030412/article/category/6145714/3" target="_blank" rel="noopener">solr从入门到精通</a></p><h3 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h3><p><a href="https://github.com/xwjie/AjaxDemo" target="_blank" rel="noopener">给公司同事和合作方详细讲解ajax的跨域访问的来龙去脉demo</a></p><h3 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h3><p><a href="http://www.cnblogs.com/constantince/category/712675.html" target="_blank" rel="noopener">Chrome开发者工具系列</a></p><h3 id="待阅-存档"><a href="#待阅-存档" class="headerlink" title="待阅/存档"></a>待阅/存档</h3><p><a href="http://www.open-open.com/lib/view/open1531058852896.html" target="_blank" rel="noopener">Java并发编程-volatile</a><br><a href="https://blog.csdn.net/jackfrued/article/details/44499227" target="_blank" rel="noopener">关于Java并发编程的总结和思考</a><br><a href="https://mp.weixin.qq.com/s/1bPLk_VZhZ0QYNZS8LkviA" target="_blank" rel="noopener">基于Redis的分布式锁真的安全吗？(上)</a><br><a href="https://yq.aliyun.com/articles/80353" target="_blank" rel="noopener">基于Redis的分布式锁真的安全吗？(下)</a><br><a href="http://www.54tianzhisheng.cn/2018/04/24/Distributed_lock/" target="_blank" rel="noopener">分布式锁看这篇就够了</a><br><a href="http://www.54tianzhisheng.cn/2018/03/06/SpringBoot2-Migration-Guide/" target="_blank" rel="noopener">Spring Boot 2.0系列文章(一)：Spring Boot 2.0 迁移指南</a><br><a href="https://yq.aliyun.com/articles/225660" target="_blank" rel="noopener">由阿里巴巴Java开发规约HashMap条目引发的故事</a><br><a href="https://mp.weixin.qq.com/s/6t_D-3qNpUuEJguNq4sIyw" target="_blank" rel="noopener">为什么分布式一定要有Redis?</a></p><h3 id="这算收集癖（不管有用没用）"><a href="#这算收集癖（不管有用没用）" class="headerlink" title="这算收集癖（不管有用没用）"></a>这算收集癖（不管有用没用）</h3><p><a href="https://www.v2ex.com/t/309499" target="_blank" rel="noopener">求助，支付系统的异步通知实现</a><br><a href="https://waylau.com/books/" target="_blank" rel="noopener">柳伟卫的开源书籍</a>（品类挺齐全的）<br><a href="https://www.zhihu.com/question/19578687" target="_blank" rel="noopener">有哪些比较好的中文分词方案？</a><br><a href="http://wiki.ubuntu.org.cn/%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8%E6%8C%87%E5%BC%95" target="_blank" rel="noopener">ubuntu新手入门指引</a><br><a href="http://iosre.com/t/topic/4152" target="_blank" rel="noopener">我的失败与伟大 —— 纪念历时18个月的初次创业</a><br><a href="https://www.zhihu.com/question/61085805" target="_blank" rel="noopener">2017年，Web后端出现了哪些新的思想和技术？</a></p><hr><p>move on</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这下疲了乏了，就多了个选择了……更新这篇O(∩_∩)O&lt;br&gt;不过收藏再多，不去看，那就毫无意义了&lt;br&gt;&lt;del&gt;倒是能满足不知道从何而来的收集癖&lt;/del&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>0711废柴下午</title>
    <link href="http://jianguoli.com/2018/07/11/0711%E5%BA%9F%E6%9F%B4%E4%B8%8B%E5%8D%88/"/>
    <id>http://jianguoli.com/2018/07/11/0711废柴下午/</id>
    <published>2018-07-11T10:05:08.000Z</published>
    <updated>2018-07-11T10:19:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天下午看了下CopyOnWriteArrayList相关的一些内容</p><ol><li>Copy-On-Write的概念</li><li>CopyOnWriteArrayList的实现</li><li>CopyOnWriteArrayList里的volatile的应用</li><li>CopyOnWriteArrayList的happen-before</li></ol><a id="more"></a><h3 id="CopyOnWriteArrayList的基本信息"><a href="#CopyOnWriteArrayList的基本信息" class="headerlink" title="CopyOnWriteArrayList的基本信息"></a>CopyOnWriteArrayList的基本信息</h3><p>在看<em>Effective Java 2rd edition</em>的第一条静态工厂方法时，作者提到服务提供者框架，并举例<code>java.sql.DriverManager</code>。于是去看了下这个类的源码，发现它是用CopyOnWriteArrayList来存储注册信息（DriverInfo）的。</p><p>Copy-On-Write的思路是：当我们往一个容器添加元素的时候，不直接往容器里添加，而是先将当前容器进行copy，然后新的容器里添加元素，添加完元素后，再将原容器的引用指向新的容器。这样做的好处是我们可以对Copy-On-Write容器进行并发的读，而不需要枷锁。所以Copy-On-Write也是一种读写分离的思想，读和写是不同的容器。</p><ul><li>CopyOnWriteArrayList的实现的关键代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyOnWriteArrayList</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">transient</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 这里为啥要用volatile？</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">        array = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object[] elements = getArray;</span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len+<span class="number">1</span>);</span><br><span class="line">            newElements[len] = e;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(getArray(),index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不明白要把get方法拆成两部分来写……</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) a[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CopyOnWrite的应用场景</li></ul><p>用于<strong>读多写少</strong>的并发场景。比如本文最初提到的java.sql.DriverManager数据库驱动注册类，更多情况是被用来调用getConnection的。</p><ul><li>CopyOnWriteArrayList的缺点：</li></ul><p>内存占用问题：因为它的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对象的内存。</p><p>数据一致性问题：CopyOnWrite容器只保证数据的最终一致性，不能保证数据的实时一致性。</p><hr><p>参考自<a href="http://ifeve.com/java-copy-on-write/" target="_blank" rel="noopener">聊聊并发-Java中的Copy-On-Write容器</a></p><h3 id="CopyOnWriteArrayList的happen-before问题与volatile解惑"><a href="#CopyOnWriteArrayList的happen-before问题与volatile解惑" class="headerlink" title="CopyOnWriteArrayList的happen-before问题与volatile解惑"></a>CopyOnWriteArrayList的happen-before问题与volatile解惑</h3><p>查看<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CopyOnWriteArrayList.html" target="_blank" rel="noopener">CopyOnWriteArrayList的api文档</a>时看到一句话：</p><blockquote><p>Memory consistency effects: As with other concurrent collections, actions in a thread prior to placing an object into a <code>CopyOnWriteArrayList</code> <a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/package-summary.html#MemoryVisibility" target="_blank" rel="noopener"><em>happen-before</em></a> actions subsequent to the access or removal of that element from the <code>CopyOnWriteArrayList</code> in another thread. </p></blockquote><p>这处写的是放入一个元素到并发集合与从并发集合中取元素之间要有<em>happen-before</em>关系（大意）。如何做到的？上文提到的volatile就是功臣之一。</p><p>尤其是该类的set实现体现了这一点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object[] elements = getArray();</span><br><span class="line">E oldValue = get(elements, index);</span><br><span class="line"><span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line"><span class="keyword">int</span> len = elements.length;</span><br><span class="line">Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">newElements[index] = element;</span><br><span class="line">setArray(newElements);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Not quite a no-op; ensures volatile write semantics</span></span><br><span class="line">setArray(elements);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> oldValue;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未详细，待补充</p><p>详见<a href="http://ifeve.com/easy-happens-before/" target="_blank" rel="noopener">happens-before俗解</a>后半部分</p><blockquote><p><em>感慨下，Java水真的好深啊</em></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天下午看了下CopyOnWriteArrayList相关的一些内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Copy-On-Write的概念&lt;/li&gt;
&lt;li&gt;CopyOnWriteArrayList的实现&lt;/li&gt;
&lt;li&gt;CopyOnWriteArrayList里的volatile的应用&lt;/li&gt;
&lt;li&gt;CopyOnWriteArrayList的happen-before&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>0709废柴下午</title>
    <link href="http://jianguoli.com/2018/07/09/0709%E5%BA%9F%E6%9F%B4%E4%B8%8B%E5%8D%88/"/>
    <id>http://jianguoli.com/2018/07/09/0709废柴下午/</id>
    <published>2018-07-09T10:11:40.000Z</published>
    <updated>2018-07-17T06:56:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录下今天下午的“收获”</p><p>内容包括</p><ol><li>相对路径和绝对路径</li><li>Tomcat7与Tomcat8编码问题</li><li>循环优化之消除循环终止判断时的方法调用</li><li>小知识：remote debugging Tomcat</li></ol><a id="more"></a><h3 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h3><p>这问题隔一段时间就会忘，这次又被困扰了，索性再“研究”一下</p><ul><li>请求转发时</li></ul><p>相对路径：<code>request.getRequestDispatcher(&quot;foo/stuff.do&quot;)</code>，字符串前补上当前路径表示完整路径</p><p>绝对路径：<code>request.getRequestDispatcher(&quot;/foo/stuff.do&quot;)</code>，字符串前面补上容器路径+项目路径表示完整路径</p><ul><li>响应重定向时</li></ul><p>相对路径：<code>response.sendRedirect(&quot;foo/stuff.do&quot;)</code>，字符串前面补上当前路径表示完整路径</p><p>绝对路径：<code>response.sendRedirect(&quot;/foo/stuff.do&quot;)</code>，字符串前面补上容器路径表示完整路径</p><ul><li>在页面上使用时</li></ul><p>如写在a标签的href里，或img标签的src里，或jsp的form表单的action里：</p><p>相对路径：<code>&lt;form action=&quot;foo/stuff.do&quot;&gt;</code>，字符串前面补上当前路径表示完整路径</p><p>绝对路径：<code>&lt;form action=&quot;/foo/stuff.do&quot;&gt;</code>，字符串前面补上容器路径表示完整路径，同响应重定向时</p><ul><li>强行归纳</li></ul><p>由此看，相对路径，即路径前不加<code>/</code>时，总是补充当前路径，而绝对路径则看发出的请求来自哪里：若是服务器内部，比如请求转发，<code>/</code>就是项目的虚拟目录，即容器路径+项目路径；若是服务器外部，<code>/</code>就是代表主机的根目录，即容器路径</p><blockquote><p>突然想到：用在<code>class.getResourceAsStream(...)</code>时，相对路径指当前路径，当前相对于package的路径，而绝对路径指跟路径</p></blockquote><hr><p><em>参考自<a href="https://yq.aliyun.com/articles/66767" target="_blank" rel="noopener">Servlet中转发和重定向的路径问题以及表单提交路径问题</a></em></p><h3 id="Tomcat7与Tomcat8编码问题"><a href="#Tomcat7与Tomcat8编码问题" class="headerlink" title="Tomcat7与Tomcat8编码问题"></a>Tomcat7与Tomcat8编码问题</h3><p>之前一直在用Tomcat7，今天得知Tomcat8默认URIEncoding是UTF-8了，遂”研究”了一波</p><p>首先是查看官方文档，可只确实Tomcat8的URIEncoding默认是UTF-8了，见如下截图：</p><p><img src="https://jianguoli-blog-img.oss-cn-hangzhou.aliyuncs.com/201807/tomcat7encoding.png" alt="tomcat7encoding"></p><p><em>from <a href="https://tomcat.apache.org/tomcat-7.0-doc/config/http.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-7.0-doc/config/http.html</a></em></p><p><img src="https://jianguoli-blog-img.oss-cn-hangzhou.aliyuncs.com/201807/tomcat8encoding.png" alt="tomcat8encoding"></p><p><em>from <a href="https://tomcat.apache.org/tomcat-8.0-doc/config/http.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-8.0-doc/config/http.html</a></em></p><p>然后搜到一篇<a href="https://yq.aliyun.com/articles/38951" target="_blank" rel="noopener">从tomcat源码角度看编码</a>的博文，摘录下其中的关键点(基于tomcat8.0.0)：</p><ul><li>org.apache.catalina.connector.Connector的URIEncoding字段，会在调用构造函数时初始化为”UTF-8”，并对外提供getURIEncoding()方法</li><li>org.apache.catalina.connector.Request的parseParameters()方法，会调用各种方法去获取characterEncoding和URIEncoding等值，来做编码处理</li><li>org.apache.coyote.Constants定义了DEFAULT_CHARACTER_ENCODING ，默认为”ISO-8859-1” </li></ul><blockquote><p>URIEncoding是指处理写在url上的参数的编码，请求体里的乱码问题还需要通过characterEncoding来处理</p></blockquote><h3 id="循环优化之消除循环终止判断时的方法调用"><a href="#循环优化之消除循环终止判断时的方法调用" class="headerlink" title="循环优化之消除循环终止判断时的方法调用"></a>循环优化之消除循环终止判断时的方法调用</h3><div class="note danger"><p>这段内容有误！！！之后重看测试代码才发现统计时间的代码有误。修正后能看出优化后有明显差异，jdk8比jdk6的差异更明显。</p></div><p>这则优化准则出现在各篇互抄的博文里，举的例子是将代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改写成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = list.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给的理由是</p><blockquote><p>list.size()每次循环都会被执行一次，这无疑会影响程序的性能，所以应该将其放到循环外面，用一个变量来代替，优化前后的对比也很明显</p></blockquote><p>我写了个demo试了下，用jdk1.8和jdk1.6，不断扩大list的size大小，然后两种方式的耗时没有那么明显的差异。其实是因为ArrayList.size()方法return的size是该类的字段，调用时没有发生计算或查询等耗时操作，所以没有性能影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of elements in this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of elements in this list</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可参考下这个回答：<a href="https://stackoverflow.com/questions/2205498/how-does-java-list-size-work" target="_blank" rel="noopener">How does Java List size() work?</a></p><h3 id="小知识：remote-debugging-Tomcat"><a href="#小知识：remote-debugging-Tomcat" class="headerlink" title="小知识：remote debugging Tomcat"></a>小知识：remote debugging Tomcat</h3><p>Tomcat用<code>./catalina.sh jpda start</code>启动，默认是8000端口</p><p>Idea配置一个Run/Debug Configurations –&gt; Remote，配下Host和Port即可</p><p>详情<a href="https://cn.bing.com/search?q=remote+debug+tomcat" target="_blank" rel="noopener">Bing一下</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下今天下午的“收获”&lt;/p&gt;
&lt;p&gt;内容包括&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;相对路径和绝对路径&lt;/li&gt;
&lt;li&gt;Tomcat7与Tomcat8编码问题&lt;/li&gt;
&lt;li&gt;循环优化之消除循环终止判断时的方法调用&lt;/li&gt;
&lt;li&gt;小知识：remote debugging Tomcat&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo + GitHub搭建博客</title>
    <link href="http://jianguoli.com/2018/07/08/Hexo-GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://jianguoli.com/2018/07/08/Hexo-GitHub搭建博客/</id>
    <published>2018-07-08T09:55:01.000Z</published>
    <updated>2018-07-23T02:30:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录下<code>Hexo</code>+<code>GitHub</code>搭建博客的操作步骤，顺便练习下<code>markdown</code>语法<br><a id="more"></a></p><h3 id="GitHub创建个人仓库"><a href="#GitHub创建个人仓库" class="headerlink" title="GitHub创建个人仓库"></a>GitHub创建个人仓库</h3><p>仓库名为用户名.github.io，例如：</p><p><img src="https://jianguoli-blog-img.oss-cn-hangzhou.aliyuncs.com/180708/github-io.png" alt="github-io" title="github-io"></p><h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p><a href="https://git-scm.com/download/win" target="_blank" rel="noopener">官网Windows版下载地址</a></p><p>安装成功后鼠标右键打开<em>Git Bash Here</em></p><p>ubuntu请<code>$ sudo apt-get install git</code></p><ul><li>设置配置信息</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"你的GitHub用户名"</span></span><br><span class="line">git config --global user.email <span class="string">"你的GitHub注册邮箱"</span></span><br></pre></td></tr></table></figure><ul><li>生成ssh密钥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"你的GitHub注册邮箱"</span></span><br></pre></td></tr></table></figure><p>然后直接敲三个回车即可，不需要设置密码</p><p>进入github的settings-&gt;SSH and GPG keys-&gt;New SSH key<br>复制<code>~/.ssh/id_rsa.pub</code>的内容key中</p><p>验证是否配置成功：<code>$ ssh git@github.com</code><br><img src="https://jianguoli-blog-img.oss-cn-hangzhou.aliyuncs.com/201807/ssh-github.png" alt="ssh-github"></p><blockquote><p>这步的作用是使得之后提交到github仓库不用一直输密码</p></blockquote><h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>windows的官方下载地址：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">点我</a></p><p>ubuntu：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_8.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure><p>验证是否安装成功：<br><img src="https://jianguoli-blog-img.oss-cn-hangzhou.aliyuncs.com/201807/installnodejs.png" alt="install-nodejs"></p><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p><em>一些指令</em></p><table><thead><tr><th>指令</th><th>效果</th></tr></thead><tbody><tr><td>npm install hexo -g</td><td>安装Hexo</td></tr><tr><td>npm update hexo -g</td><td>升级</td></tr><tr><td>hexo init</td><td>初始化博客</td></tr></tbody></table><hr><p>更多待续。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录下&lt;code&gt;Hexo&lt;/code&gt;+&lt;code&gt;GitHub&lt;/code&gt;搭建博客的操作步骤，顺便练习下&lt;code&gt;markdown&lt;/code&gt;语法&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
